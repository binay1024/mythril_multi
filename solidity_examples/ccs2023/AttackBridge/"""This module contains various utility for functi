"""This module contains various utility for function signature parsing"""
import re

import pytest
from mythril.laser.ethereum.state.calldata import ConcreteCalldata, SymbolicCalldata
from mythril.laser.smt import Solver, symbol_factory
from z3 import sat, unsat
from z3.z3types import Z3Exception
from mock import MagicMock


uninitialized_test_data = [
    ([]),  # Empty concrete calldata
    ([1, 4, 5, 3, 4, 72, 230, 53]),  # Concrete calldata
]



@pytest.mark.parametrize("starting_calldata", uninitialized_test_data)
def test_concrete_calldata_uninitialized_index(starting_calldata):
    # Arrange
    calldata = ConcreteCalldata(0, starting_calldata)

    # Act
    value = calldata[100]
    value2 = calldata.get_word_at(200)

    # Assert
    assert value == 0
    assert value2 == 0


def test_concrete_calldata_calldatasize():
    # Arrange
    calldata = ConcreteCalldata(0, [1, 4, 7, 3, 7, 2, 9])
    solver = Solver()

    # Act
    solver.check()
    model = solver.model()
    result = model.eval(calldata.calldatasize.raw)

    # Assert
    assert result == 7


def test_concrete_calldata_constrain_index():
    # Arrange
    calldata = ConcreteCalldata(0, [1, 4, 7, 3, 7, 2, 9])
    solver = Solver()

    # Act
    value = calldata[2]
    constraint = value == 3

    solver.add(constraint)
    result = solver.check()

    # Assert
    assert str(result) == "unsat"


def test_symbolic_calldata_constrain_index():
    # Arrange
    calldata = SymbolicCalldata(0)
    solver = Solver()

    # Act
    value = calldata[51]

    constraints = [value == 1, calldata.calldatasize == 50]

    solver.add(*constraints)

    result = solver.check()

    # Assert
    assert str(result) == "unsat"


def test_symbolic_calldata_equal_indices():
    calldata = SymbolicCalldata(0)

    index_a = symbol_factory.BitVecSym("index_a", 256)
    index_b = symbol_factory.BitVecSym("index_b", 256)

    # Act
    a = calldata[index_a]
    b = calldata[index_b]

    s = Solver()
    s.append(index_a == index_b)
    s.append(a != b)

    # Assert
    assert unsat == s.check()

##################################3

STATIC_TYPE_LIST = [   
    "bool", 
    "int", 
    "uint", 
             #   "fixed",
             #   "ufixed",
    "address",
    "bytesM",
    
            #    "function", 
    ]
DYNAMIC_TYPE_LIST = [
    "bytes",
    "string",
]

TYPE_SIZE = {
    "bool": 32,     # 静态
    "int": 32,      # 静态
    "uint": 32,     # 静态
    "bytes": 96,    # 动态
    "bytesM": 32,   # 静态
    "string":96,    # 动态
    # "fixed",
    # "ufixed",
    "address": 32,  # 静态
    # "function", 
}
################################################

def signature_parsing(sig_:str) -> list:
    # 首先 去掉空白字符
    sig_ = sig_.strip()

    # 找到 左括号和右括号的位置
    left_pare = sig_.find('(')
    righ_pare = sig_.find(')')

    if left_pare == -1 or righ_pare == -1:
        return []
    
    # 找到括号之后, 提取括号之间的内容
    parameters = sig_[left_pare+1:righ_pare]

    # 根据逗号分割参数并返回 
    return [para.strip() for para in parameters.split(',')]


def pure_sig(para_list:list[str]) -> list:
    number = r'\d'
    return [ "bytesM" if 'bytes' in para and len(para) > 5 else re.sub(number, '',para) for para in para_list]
    # return [re.sub(number, '',para) for para in para_list]

def calcu_paras_size (pure_para_list:list[str]) -> list:
    # return [TYPE_SIZE.get(typ, 0) for typ in pure_para_list]
    return [ calcu_para_size(typ) for typ in pure_para_list]

def calcu_para_size (pure_para:str) -> int:
    return TYPE_SIZE.get(pure_para, 0)



if __name__ == "__main__":
    sig1 = "foo(uint256)"
    sig2 = "foo(bytes)"
    sig3 = "foo(uint256,bytes)"
    sig4 = "foo(uint256,bytes4)"
    print("Test sig1 {}".format(sig1))
    signature1 = signature_parsing(sig1)
    # print("result: {}".format(signature_parsing(sig1)))
    # print("Pure result: {}".format(pure_sig(signature_parsing(sig1))))
    print("Pure result: {}".format(calcu_paras_size(pure_sig(signature_parsing(sig1)))))
    
    print("Test sig2 {}".format(sig2))
    signature2 = signature_parsing(sig2)
    # print("result: {}".format(signature_parsing(sig2)))
    # print("Pure result: {}".format(pure_sig(signature_parsing(sig2))))
    print("Pure result: {}".format(calcu_paras_size(pure_sig(signature_parsing(sig2)))))
    
    print("Test sig3 {}".format(sig3))
    signature1 = signature_parsing(sig1)
    # print("result: {}".format(signature_parsing(sig3)))
    # print("Pure result: {}".format(pure_sig(signature_parsing(sig3))))
    print("Pure result: {}".format(calcu_paras_size(pure_sig(signature_parsing(sig3)))))
    print("Test sig4 {}".format(sig4))
    # print("result: {}".format(signature_parsing(sig4)))
    # print("Pure result: {}".format(pure_sig(signature_parsing(sig4))))
    print("Pure result: {}".format(calcu_paras_size(pure_sig(signature_parsing(sig4)))))